const express = require('express');
const router = express.Router();
const { requireAuth } = require('../middleware/auth');
const { requireRole } = require('../middleware/rbac');
const { db } = require('../config/database');

const PHASES = ['recon', 'enumeration', 'vuln_id', 'exploitation', 'reporting'];
const PHASE_LABELS = {
  recon:       'Reconnaissance',
  enumeration: 'Enumeration',
  vuln_id:     'Vulnerability Identification',
  exploitation:'Exploitation',
  reporting:   'Reporting'
};

function nextPhase(current) {
  const idx = PHASES.indexOf(current);
  return idx < PHASES.length - 1 ? PHASES[idx + 1] : null;
}

function getOrCreateEngagement(studentId) {
  let eng = db.prepare('SELECT * FROM pentest_engagements WHERE student_id = ?').get(studentId);
  if (!eng) {
    const result = db.prepare(`
      INSERT INTO pentest_engagements (student_id, title, status, phase_current)
      VALUES (?, ?, ?, ?)
    `).run(studentId, 'Pentest Engagement', 'in_progress', 'recon');
    eng = db.prepare('SELECT * FROM pentest_engagements WHERE student_id = ?').get(studentId);
  }
  return eng;
}

// ─── GET /pentest ─── Landing
router.get('/', requireAuth, (req, res) => {
  const user = req.session.user;
  if (user.role === 'student') return res.redirect('/pentest/my');

  // Instructor: all engagements
  const engagements = db.prepare('SELECT * FROM pentest_engagements').all();
  const students = db.prepare('SELECT * FROM users WHERE role = ?').all('student');
  const studentMap = {};
  students.forEach(s => { studentMap[s.id] = s; });

  res.render('pentest/instructor', {
    title: 'Pentest Lab — Instructor',
    engagements,
    studentMap,
    PHASES,
    PHASE_LABELS
  });
});

// ─── GET /pentest/engagements ─── Instructor: all engagements
router.get('/engagements', requireAuth, requireRole(['admin', 'professor']), (req, res) => {
  return res.redirect('/pentest');
});

// ─── GET /pentest/engagements/:id ─── Instructor: specific engagement
router.get('/engagements/:id', requireAuth, requireRole(['admin', 'professor']), (req, res) => {
  const eng = db.prepare('SELECT * FROM pentest_engagements WHERE id = ?').get(parseInt(req.params.id));
  if (!eng) return res.status(404).render('error', { message: 'Engagement not found', error: { status: 404 } });

  const findings = db.prepare('SELECT * FROM pentest_findings WHERE engagement_id = ?').all(eng.id);
  const phaseNotes = db.prepare('SELECT * FROM pentest_phase_notes WHERE engagement_id = ?').all(eng.id);
  const notesMap = {};
  phaseNotes.forEach(n => { notesMap[n.phase] = n; });

  const student = db.prepare('SELECT * FROM users WHERE id = ?').get(eng.student_id);

  res.render('pentest/engagement-detail', {
    title: `Pentest: ${student ? student.username : eng.student_id}`,
    eng, findings, notesMap, student, PHASES, PHASE_LABELS
  });
});

// ─── GET /pentest/my ─── Student: their engagement (auto-create)
router.get('/my', requireAuth, requireRole(['student']), (req, res) => {
  const eng = getOrCreateEngagement(req.session.user.id);
  const findings = db.prepare('SELECT * FROM pentest_findings WHERE engagement_id = ?').all(eng.id);
  const phaseNotes = db.prepare('SELECT * FROM pentest_phase_notes WHERE engagement_id = ?').all(eng.id);

  const findingsByPhase = {};
  const notesMap = {};
  PHASES.forEach(p => { findingsByPhase[p] = []; });
  findings.forEach(f => { if (findingsByPhase[f.phase]) findingsByPhase[f.phase].push(f); });
  phaseNotes.forEach(n => { notesMap[n.phase] = n; });

  res.render('pentest/student-lab', {
    title: 'Pentest Lab',
    eng,
    findingsByPhase,
    notesMap,
    PHASES,
    PHASE_LABELS,
    nextPhase: nextPhase(eng.phase_current)
  });
});

// ─── GET /pentest/my/report ─── Report builder
router.get('/my/report', requireAuth, requireRole(['student']), (req, res) => {
  const eng = getOrCreateEngagement(req.session.user.id);
  const findings = db.prepare('SELECT * FROM pentest_findings WHERE engagement_id = ?').all(eng.id);
  const phaseNotes = db.prepare('SELECT * FROM pentest_phase_notes WHERE engagement_id = ?').all(eng.id);

  const findingsByPhase = {};
  const notesMap = {};
  PHASES.forEach(p => { findingsByPhase[p] = []; });
  findings.forEach(f => { if (findingsByPhase[f.phase]) findingsByPhase[f.phase].push(f); });
  phaseNotes.forEach(n => { notesMap[n.phase] = n; });

  const sevOrder = { Critical: 0, High: 1, Medium: 2, Low: 3, Info: 4 };
  findings.sort((a, b) => (sevOrder[a.severity] || 5) - (sevOrder[b.severity] || 5));

  res.render('pentest/report-builder', {
    title: 'Pentest Report',
    eng, findings, findingsByPhase, notesMap, PHASES, PHASE_LABELS
  });
});

// ─── PUT /pentest/my/phase ─── Advance phase (guard: ≥1 finding)
router.post('/my/phase/advance', requireAuth, requireRole(['student']), (req, res) => {
  const eng = getOrCreateEngagement(req.session.user.id);
  if (eng.status === 'submitted' || eng.status === 'graded') {
    return res.status(400).json({ success: false, error: 'Engagement already submitted' });
  }

  const currentFindings = db.prepare(
    'SELECT * FROM pentest_findings WHERE engagement_id = ? AND phase = ?'
  ).all(eng.id, eng.phase_current);

  if (!currentFindings.length) {
    return res.status(400).json({ success: false, error: `Add at least one finding in ${PHASE_LABELS[eng.phase_current]} before advancing.` });
  }

  const next = nextPhase(eng.phase_current);
  if (!next) {
    return res.status(400).json({ success: false, error: 'Already at final phase. Submit your report instead.' });
  }

  db.prepare('UPDATE pentest_engagements SET phase_current = ? WHERE id = ?').run(next, eng.id);
  res.json({ success: true, nextPhase: next, nextLabel: PHASE_LABELS[next] });
});

// ─── POST /pentest/my/phases/:phase/notes ─── Save phase narrative
router.post('/my/phases/:phase/notes', requireAuth, requireRole(['student']), (req, res) => {
  const phase = req.params.phase;
  if (!PHASES.includes(phase)) return res.status(400).json({ success: false, error: 'Invalid phase' });

  const eng = getOrCreateEngagement(req.session.user.id);
  const { notes, tools_used } = req.body;

  const existing = db.prepare(
    'SELECT * FROM pentest_phase_notes WHERE engagement_id = ? AND phase = ?'
  ).get(eng.id, phase);

  if (existing) {
    db.prepare('UPDATE pentest_phase_notes SET notes = ?, tools_used = ?, updated_at = ? WHERE engagement_id = ? AND phase = ?')
      .run(notes || '', tools_used || '', new Date().toISOString(), eng.id, phase);
  } else {
    db.prepare(`
      INSERT INTO pentest_phase_notes (engagement_id, phase, notes, tools_used)
      VALUES (?, ?, ?, ?)
    `).run(eng.id, phase, notes || '', tools_used || '');
  }

  res.json({ success: true });
});

// ─── POST /pentest/my/phases/:phase/findings ─── Add finding
router.post('/my/phases/:phase/findings', requireAuth, requireRole(['student']), (req, res) => {
  const phase = req.params.phase;
  if (!PHASES.includes(phase)) return res.status(400).json({ success: false, error: 'Invalid phase' });

  const eng = getOrCreateEngagement(req.session.user.id);
  if (eng.status === 'submitted' || eng.status === 'graded') {
    return res.status(400).json({ success: false, error: 'Cannot add findings to a submitted engagement' });
  }

  const { title, severity, cvss_score, description, affected_url, evidence, recommendation } = req.body;
  if (!title) return res.status(400).json({ success: false, error: 'title required' });

  const result = db.prepare(`
    INSERT INTO pentest_findings (engagement_id, phase, title, severity, cvss_score, description, affected_url, evidence, recommendation)
    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
  `).run(eng.id, phase, title, severity || 'Medium', cvss_score || null,
    description || null, affected_url || null, evidence || null, recommendation || null);

  if (req.headers.accept && req.headers.accept.includes('application/json')) {
    return res.json({ success: true, findingId: result.lastID });
  }
  res.redirect('/pentest/my');
});

// ─── PUT /pentest/my/findings/:id ─── Edit own finding
router.post('/my/findings/:id/update', requireAuth, requireRole(['student']), (req, res) => {
  const findingId = parseInt(req.params.id);
  const finding = db.prepare('SELECT * FROM pentest_findings WHERE id = ?').get(findingId);
  if (!finding) return res.status(404).json({ success: false, error: 'Not found' });

  const eng = db.prepare('SELECT * FROM pentest_engagements WHERE id = ?').get(finding.engagement_id);
  if (!eng || eng.student_id !== req.session.user.id) {
    return res.status(403).json({ success: false, error: 'Forbidden' });
  }
  if (eng.status === 'submitted' || eng.status === 'graded') {
    return res.status(400).json({ success: false, error: 'Cannot edit a submitted engagement' });
  }

  const { title, severity, cvss_score, description, affected_url, evidence, recommendation } = req.body;
  db.prepare(`
    UPDATE pentest_findings SET title = ?, severity = ?, cvss_score = ?, description = ?, affected_url = ?, evidence = ?, recommendation = ?
    WHERE id = ?
  `).run(title || finding.title, severity || finding.severity, cvss_score || null,
    description || null, affected_url || null, evidence || null, recommendation || null, findingId);

  res.json({ success: true });
});

// ─── DELETE /pentest/my/findings/:id ─── Delete own finding
router.post('/my/findings/:id/delete', requireAuth, requireRole(['student']), (req, res) => {
  const findingId = parseInt(req.params.id);
  const finding = db.prepare('SELECT * FROM pentest_findings WHERE id = ?').get(findingId);
  if (!finding) return res.status(404).json({ success: false, error: 'Not found' });

  const eng = db.prepare('SELECT * FROM pentest_engagements WHERE id = ?').get(finding.engagement_id);
  if (!eng || eng.student_id !== req.session.user.id) {
    return res.status(403).json({ success: false, error: 'Forbidden' });
  }
  if (eng.status === 'submitted' || eng.status === 'graded') {
    return res.status(400).json({ success: false, error: 'Cannot delete from a submitted engagement' });
  }

  db.prepare('DELETE FROM pentest_findings WHERE id = ?').run(findingId);
  res.json({ success: true });
});

// ─── POST /pentest/my/submit ─── Submit engagement
router.post('/my/submit', requireAuth, requireRole(['student']), (req, res) => {
  const eng = getOrCreateEngagement(req.session.user.id);
  if (eng.status === 'submitted' || eng.status === 'graded') {
    return res.status(400).json({ success: false, error: 'Already submitted' });
  }

  // All 5 phases must have at least 1 finding
  const incomplete = [];
  PHASES.forEach(phase => {
    const count = db.prepare(
      'SELECT * FROM pentest_findings WHERE engagement_id = ? AND phase = ?'
    ).all(eng.id, phase).length;
    if (!count) incomplete.push(PHASE_LABELS[phase]);
  });

  if (incomplete.length) {
    return res.status(400).json({
      success: false,
      error: `Missing findings in: ${incomplete.join(', ')}`
    });
  }

  db.prepare(`UPDATE pentest_engagements SET status = ?, submitted_at = ? WHERE id = ?`)
    .run('submitted', new Date().toISOString(), eng.id);

  res.json({ success: true });
});

// ─── POST /pentest/engagements/:id/grade ─── Grade (instructor+)
router.post('/engagements/:id/grade', requireAuth, requireRole(['admin', 'professor']), (req, res) => {
  const engId = parseInt(req.params.id);
  const eng = db.prepare('SELECT * FROM pentest_engagements WHERE id = ?').get(engId);
  if (!eng) return res.status(404).json({ success: false, error: 'Not found' });

  const { instructor_grade, instructor_feedback } = req.body;
  db.prepare(`
    UPDATE pentest_engagements SET instructor_grade = ?, instructor_feedback = ?, status = ? WHERE id = ?
  `).run(instructor_grade || null, instructor_feedback || null, 'graded', engId);

  res.json({ success: true });
});

// ─── POST /pentest/import-to-vm/:id ─── Bulk import all findings from an engagement
router.post('/import-to-vm/:id', requireAuth, requireRole(['admin', 'professor']), (req, res) => {
  const engId = parseInt(req.params.id);
  const eng = db.prepare('SELECT * FROM pentest_engagements WHERE id = ?').get(engId);
  if (!eng) return res.status(404).json({ success: false, error: 'Engagement not found' });

  const findings = db.prepare('SELECT * FROM pentest_findings WHERE engagement_id = ?').all(engId);
  const results = [];
  const now = new Date().toISOString();

  findings.forEach(f => {
    const existing = db.prepare(
      'SELECT * FROM vulnerabilities WHERE source = ? AND source_id = ?'
    ).get('pentest', f.id);

    if (existing) {
      results.push({ findingId: f.id, success: false, error: 'Already imported', vulnId: existing.id });
      return;
    }

    const result = db.prepare(`
      INSERT INTO vulnerabilities (id, title, source, source_id, owasp_category, cwe, cvss_vector, cvss_score,
        severity, affected_component, description, status, assigned_to, priority,
        remediation_plan, remediation_deadline, created_at, updated_at)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `).run(0, f.title, 'pentest', f.id, null, null, null, f.cvss_score,
      f.severity, f.affected_url, f.description, 'open', null, 2, f.recommendation, null, now, now);

    results.push({ findingId: f.id, success: true, vulnId: result.lastID });
  });

  const imported = results.filter(r => r.success).length;
  const skipped  = results.filter(r => !r.success).length;
  res.json({ success: true, imported, skipped, results });
});

module.exports = { router };
